<?xml-stylesheet type="text/xsl" href="summary.xsl"?>
<lv:package
  xmlns:lv="http://www.lovullo.com/rater"
  xmlns:c="http://www.lovullo.com/calc"
  xmlns:t="http://www.lovullo.com/rater/apply-template"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.lovullo.com/rater ../../rater.xsd"

  core="true"

  name="core/vector/arithmetic"
  desc="Vector arithmetic">

  <lv:import package="../base" />
  <lv:import package="../numeric/common" />
  <lv:import package="../numeric/minmax" />



  <!-- for the time being, the vectors must be of the same length, or the first
       vector must be the longer (otherwise the values will not properly add)
       -->
  <lv:template name="_vadd_" desc="Produce a vector resulting from the addition of two vectors">
    <lv:param name="@a@" desc="First vector to add" />
    <lv:param name="@b@" desc="Second vector to add" />
    <lv:param name="@into@" desc="Variable to yield vector into" />

    <lv:param name="@yields@" desc="Value to yield (useless)">
      <lv:text>__</lv:text>
      <lv:param-value name="@into@" />
    </lv:param>

    <lv:param name="@gendesc@" desc="Generator description (for @into@)">
      <lv:text>Sum of vectors </lv:text>
      <lv:param-value name="@a@" />
      <lv:text> and </lv:text>
      <lv:param-value name="@b@" />
    </lv:param>

    <lv:param name="@sym@" desc="Generator symbol">
      <!-- empty by default -->
      <lv:text></lv:text>
    </lv:param>

    <lv:rate accumulate="none" yields="@yields@">
      <c:sum of="@a@" index="k" generates="@into@" desc="@gendesc@" sym="@sym@">
        <c:value-of name="@a@" index="k" />
        <c:value-of name="@b@" index="k" />
      </c:sum>
    </lv:rate>
  </lv:template>


  <!-- the template version of the function -->
  <lv:template name="_maxreduce_" desc="Reduce a set to its maximum">
    <lv:param name="@values@" desc="Values to reduce" />
    <lv:param name="@isvector@" desc="Set to 'true' if the nodes should not be wrapped in c:set" />
    <lv:param name="@label@" desc="Application label">
      <!-- default empty -->
      <lv:text></lv:text>
    </lv:param>

    <c:apply name="maxreduce" label="@label@">
      <c:arg name="maxreduce_set">
        <!-- if we were not provided with a vector (default), create one out of
             the given nodes -->
        <lv:unless name="@isvector@" eq="true">
          <c:set>
            <lv:param-copy name="@values@" />
          </c:set>
        </lv:unless>

        <!-- if they told us that they have provided a vector, then do not
             create one -->
        <lv:if name="@isvector@" eq="true">
          <lv:param-copy name="@values@" />
        </lv:if>
      </c:arg>
    </c:apply>
  </lv:template>


  <lv:function name="maxreduce" desc="Reduce a set to its maximum">
    <lv:param name="maxreduce_set" type="float" set="vector" desc="Set to find max of" />

    <c:let>
      <c:values>
        <c:value name="n" type="integer" desc="Length of set to reduce">
          <c:length-of>
            <c:value-of name="maxreduce_set" />
          </c:length-of>
        </c:value>
      </c:values>


      <c:cases>
        <!-- if we have no values to reduce, then simply return 0 -->
        <c:case>
          <c:when name="n">
            <c:eq>
              <c:const value="0" type="integer" desc="When there are no elements" />
            </c:eq>
          </c:when>

          <c:const value="0" type="integer" desc="No value" />
        </c:case>

        <!-- we have values; perform reduction -->
        <c:otherwise>
          <c:apply name="_maxreduce">
            <c:arg name="_maxreduce_set">
              <c:value-of name="maxreduce_set" />
            </c:arg>

            <c:arg name="_maxreduce_i">
              <t:dec>
                <c:length-of>
                  <c:value-of name="maxreduce_set" />
                </c:length-of>
              </t:dec>
            </c:arg>
          </c:apply>
        </c:otherwise>
      </c:cases>
    </c:let>
  </lv:function>


  <!--
    Recursively determines the maximum value of the given set

    For example, given the set (2 4 3 1), here's the recursive application:
      max( 1, max( 3, max( 4, 2 ) ) )
      max( 1, max( 3, 4 ) )
      max( 1, 4 )
      4

    Of course, the above can be done manually, but this function exists
    explicitly to cut down on that manual code, especially considering how
    verbose function applications are.

    TODO: If we can support variable applications, then this simply be a
    generic reduce function that accepts max/min/etc.
  -->
  <lv:function name="_maxreduce" desc="Recursively reduce a set to its maximum (called by maxreduce)">
    <lv:param name="_maxreduce_set" type="float" set="vector" desc="Set to find max of" />
    <lv:param name="_maxreduce_i"   type="integer" desc="Index" />

    <c:cases>
      <!-- base case: if we're on the last index, do not recurse -->
      <c:case>
        <c:when name="_maxreduce_i">
          <c:eq>
            <c:const value="0" type="integer" desc="Return when only one element remains" />
          </c:eq>
        </c:when>

        <!-- return the first value -->
        <c:value-of name="_maxreduce_set">
          <c:index>
            <c:const value="0" type="integer" desc="First item in set" />
          </c:index>
        </c:value-of>
      </c:case>

      <!-- we have more elements in the set; recursively determine the maximum value -->
      <c:otherwise>
        <c:apply name="max">
          <!-- the first element to compare is our index -->
          <c:arg name="max1">
            <c:value-of name="_maxreduce_set">
              <c:index>
                <c:value-of name="_maxreduce_i" />
              </c:index>
            </c:value-of>
          </c:arg>

          <!-- and we'll compare to the recursive application of the same set
               on the previous index -->
          <c:arg name="max2">
            <c:apply name="_maxreduce">
              <c:arg name="_maxreduce_set">
                <c:value-of name="_maxreduce_set" />
              </c:arg>

              <c:arg name="_maxreduce_i">
                <c:sum>
                  <c:value-of name="_maxreduce_i" />
                  <c:const value="-1" type="integer" desc="Decrement index by 1" />
                </c:sum>
              </c:arg>
            </c:apply>
          </c:arg>
        </c:apply>
      </c:otherwise>
    </c:cases>
  </lv:function>


  <!-- simplifies retrieving the max of a set of values -->
  <lv:template name="_maxOfEach_" desc="Take the max of the given set of values">
    <lv:param name="@class@" desc="Class to match on" />
    <lv:param name="@values@" desc="Individual values without lv:set" />
    <lv:param name="@generates@" desc="Value to generate into" />
    <lv:param name="@index@" desc="Index to use for rate-each" />

    <lv:param name="@yields@" desc="Yield variable">
      <lv:text>_</lv:text>
      <lv:param-value name="@generates@" />
    </lv:param>

    <lv:rate-each class="@class@" accumulate="none" yields="@yields@" generates="@generates@" index="@index@">
      <c:apply name="maxreduce">
        <c:arg name="maxreduce_set">
          <c:set>
            <lv:param-copy name="@values@" />
          </c:set>
        </c:arg>
      </c:apply>
    </lv:rate-each>
  </lv:template>


  <lv:template name="_vsum_" desc="Yield sum of all elements of a vector as a scalar">
    <lv:param name="@of@"     desc="Vector to sum" />
    <lv:param name="@yields@" desc="Name of scalar to yield" />

    <lv:rate yields="@yields@">
      <c:sum of="@of@" />
    </lv:rate>
  </lv:template>
</lv:package>
