<?xml version="1.0"?>
<!--
  Copyright (C) 2015  LoVullo Associates, Inc.

  This file is part of tame-core.

  tame-core is free software: you can redistribute it and/or modify it
  under the terms of the GNU Lesser General Public License as
  published by the Free Software Foundation, either version 3 of the
  License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->
<package xmlns="http://www.lovullo.com/rater"
         xmlns:c="http://www.lovullo.com/calc"
         core="true"
         desc="Base features">

  The \pkgself~package exposes common and internal
  defintions.  Ideally, this package will be included automatically by
  the compiler to remove repetitive, boilerplate imports.  Importing
  this package isn't necessary if none of these definitions are
  needed.



  <section title="Internal Constants">
    \ref{_CMATCH_} is a magic constant that contains the result of
    a~classification match.  This is used implicity by
    \ref{rate-each}.\footnote{The symbol is \Xi~because it looks like
    a sideways array.}

    \todo{Remove in favor of a local variable or generated
    classification; there is no need (anymore) for this to be magic.}

    <const name="_CMATCH_" type="boolean" sym="\Xi"
           desc="Set indicating indexes of classification matches">
      <item value="0"
            desc="Dummy value; this set is populated upon entering
                  each rate block" />
    </const>


    The runtime is responsible for populating \ref{__DATE_YEAR__} with
    a proper value representing the current year.

    \todo{TAME is deterministic with this one exception; remove it and
    have users use a param instead if they need this datum.}

    <const name="__DATE_YEAR__" magic="true"
           value="0" type="integer"
           desc="Current year"
           sym="\widehat{D^\gamma}" />
  </section>



  <section title="Primitive Types">
    Primitives are defined internally; these definitions simply
    provide symbols to permit their use.

    <typedef name="integer"
             desc="Any value in the set of integers"
             sym="\mathbb{I}">
      <base-type />
    </typedef>


    <typedef name="float"
             desc="Any real number (represented as a float)"
             sym="\mathbb{R}">
      <base-type />
    </typedef>


    <typedef name="boolean" desc="Boolean values">
      <enum type="integer">
        <item name="TRUE"  value="1" desc="True" />
        <item name="FALSE" value="0" desc="False" />
      </enum>
    </typedef>


    \ref{empty} does not have much use outside of the compiler.

    <typedef name="empty"
             desc="Empty set"
             sym="\emptyset">
      <base-type />
    </typedef>
  </section>



  <section title="Convenience">
    Negation is a common task and it was tedious in older versions of
    TAME\footnote{Before it was even called TAME, actually.}  For
    these situations, \ref{NEGATE} is provided to avoid having to use
    a~\ref{const} expression.

    <const name="NEGATE" value="-1"
           desc="Negate a value"
           sym="-" />


    Similarly, $0$~is a~common value.  Where a value is required (such
    as a~template argument), \ref{ZERO} may be used.  TAME now
    supports a~constant-scalar syntax ({\tt #0}; \todo{reference this
    in documentation}), making this largely unnecessary.

    This is declared as a float to provide compatibility with all
    types of expressions.

    <const name="ZERO" value="0.00"
           desc="Zero value" />


    In the case where classifications are required, but a~static
    assumption about the applicability of the subject can be made, we
    have values that are always~true and always~false.  The use
    of~\ref{never} may very well be a~code smell, but let us not rush
    to judgment.\footnote{\ref{never} has been added as an analog
    to~\ref{always}; its author has never had use for it.  Oh, look,
    we just used ``never''.}

    <classify as="always"
              desc="Always true"
              yields="alwaysTrue"
              keep="true" />

    <classify as="never"
              desc="Never true"
              yields="neverTrue"
              keep="true" />
  </section>



  <section title="Work-In-Progress">
    The templates in this section handle code that is
    a~work-in-progress; they should probably not be used in production
    code, since they indicate that something is incomplete or unused.

    \ref{_todo_} formalizes TODO items and \may~always yield a scalar
    integer~0, so it may be used within calculations.  If yielding a
    constant value is not appropriate, it \may~also be stripped from
    the output entirely.

    <template name="_todo_"
              desc="Represents work that needs to be done">
      <param name="@desc@" desc="TODO desc">
        <text>TODO</text>
      </param>

      <param name="@hide@" desc="Whether to hide content by stripping
                                 it entriely from the output" />

      <unless name="@hide@">
        <c:const value="0"
                 desc="@desc@" />
      </unless>
    </template>


    The \ref{_ignore_} template serves as a~block
    comment.\footnote{This is useful since XML does not support nested
    comments, which makes it difficult to comment out code that
    already has XML comments.}  It may be useful for debugging, but is
    discouraged for use otherwise.  The \ref{_ignore_/@desc@} param
    should be used to describe intent.

    <template name="_ignore_"
              desc="Removes all child nodes (as if commented out)">
      <param name="@values@" desc="Nodes to comment out" />
      <param name="@desc@"   desc="Reason for ignore" />

      <!-- nothing -->
    </template>
  </section>



  <!-- Everything below this line must be moved. -->


  <template name="_fail-on-empty_" desc="Fail on rate lookup failure">
    <param name="@values@" desc="Optional conditions to include in match" />
    <param name="@name@" desc="Data to check (scalar, vector or otherwise)" />
    <param name="@when@" desc="Conditional check (optional)" />
    <param name="@class@" desc="Conditional class check" />

    <param name="@as@" desc="Classifier name">
      <text>-err-empty-</text>
      <param-value name="@name@" lower="true" />
    </param>

    <param name="@desc@" desc="Description">
      <param-value name="@name@" />
      <text> is empty</text>
    </param>

    <param name="@classyields@" desc="Classification yield to match on">
      <param-class-to-yields name="@class@" />
    </param>

    <!-- default to external to ensure that calculations do not wind up in the
         classifier -->
    <param name="@external@" desc="External classification">
      <text>true</text>
    </param>


    <classify as="@as@" desc="@desc@" external="@external@" terminate="true">
      <!-- include any option conditions -->
      <param-copy name="@values@" />

      <if name="@when@">
        <match on="@when@" value="TRUE" />
      </if>

      <if name="@class@">
        <match on="@classyields@" value="TRUE" />
      </if>

      <match on="@name@" value="ZERO" />
    </classify>
  </template>
</package>

